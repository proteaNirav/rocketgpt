name: Auto Update Policy (Controlled)

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Update mode (allowlist_patch|evidence_only)"
        required: false
        default: "evidence_only"
        type: string
      reason:
        description: "Why is this update needed?"
        required: true
        type: string
      target_branch:
        description: "Branch to operate on"
        required: false
        default: "main"
        type: string

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: auto-update-policy
  cancel-in-progress: false

jobs:
  auto_update:
    name: Controlled Auto-Update
    runs-on: ubuntu-latest
    env:
      # Use PAT for gh CLI to allow PRs to trigger workflows
      GH_TOKEN: ${{ secrets.RGPT_AUTOMATION_PAT }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.RGPT_AUTOMATION_PAT }}
          fetch-depth: 0
          ref: ${{ inputs.target_branch }}

      - name: Preflight - clean repo
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "$(git status --porcelain)" ]; then
            echo "::error::Working tree not clean before auto-update"
            git status --porcelain || true
            exit 1
          fi
          echo "[AUTO-UPDATE] Clean working tree confirmed."

      - name: Apply update (L1-only)
        shell: bash
        run: |
          set -euo pipefail

          MODE="${{ inputs.mode }}"
          if [ -z "${MODE}" ]; then MODE="evidence_only"; fi
          echo "[AUTO-UPDATE] mode=${MODE}"

          # Allowed L1 targets (explicit)
          ALLOW_1=".github/auto-ops.yml"

          if [ "${MODE}" = "evidence_only" ]; then
            echo "[AUTO-UPDATE] evidence_only: no repo mutation."
            echo "reason=${{ inputs.reason }}" > auto_update_reason.txt
            exit 0
          fi

          if [ "${MODE}" != "allowlist_patch" ]; then
            echo "::error::Invalid mode: ${MODE}. Allowed: allowlist_patch|evidence_only"
            exit 1
          fi

          if [ ! -f "${ALLOW_1}" ]; then
            echo "::error::Missing allowlist file: ${ALLOW_1}"
            exit 1
          fi

          # Safe patch: append an audit comment
          printf "\n# auto-update: %s by %s\n" "$(date -u +%Y-%m-%dT%H:%M:%SZ)" "${GITHUB_ACTOR}" >> "${ALLOW_1}"
          echo "[AUTO-UPDATE] Patched allowlist: ${ALLOW_1}"

          # Hard stop: ensure ONLY allowed file changed (plus local temp file)
          CHANGED="$(git diff --name-only | sed '/^\s*$/d' || true)"
          echo "[AUTO-UPDATE] Changed files after patch:"
          echo "${CHANGED}" || true

          bad=0
          while IFS= read -r f; do
            [ -z "$f" ] && continue
            case "$f" in
              .github/auto-ops.yml|auto_update_reason.txt)
                ;;
              *)
                echo "::error::Blocked change outside L1 allowlist: $f"
                bad=1 ;;
            esac
          done <<< "${CHANGED}"

          if [ "$bad" -ne 0 ]; then
            exit 1
          fi

      - name: Enforce L0 immutability
        shell: bash
        run: |
          set -euo pipefail
          blocked=0

          git diff --name-only | sed '/^\s*$/d' > changed_files.txt || true

          while IFS= read -r f; do
            case "$f" in
              .github/workflows/policy_gate.yml|\
              docs/ops/policy/POLICY_OWNERSHIP_MATRIX.md|\
              docs/ops/ledger/*)
                echo "::error::Blocked L0 change: $f"
                blocked=1 ;;
              *)
                ;;
            esac
          done < changed_files.txt

          if [ "$blocked" -ne 0 ]; then
            exit 1
          fi

          echo "[AUTO-UPDATE] L0 integrity OK."

      - name: Create execution evidence
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          ts="$(date -u +%Y%m%d-%H%M%SZ)"
          dir="docs/ops/executions/RGPT-S2-C-13"
          mkdir -p "$dir"
          cat > "$dir/AUTO_UPDATE_RUN_$ts.md" <<EOF
# Auto-Update Policy Run
- UTC: $ts
- Branch: ${{ inputs.target_branch }}
- Actor: ${{ github.actor }}
- Reason: ${{ inputs.reason }}
- SHA: ${{ github.sha }}
EOF

      - name: Commit and create PR
        shell: bash
        run: |
          set -euo pipefail

          # If nothing changed, exit cleanly.
          if [ -z "$(git status --porcelain)" ]; then
            echo "[AUTO-UPDATE] Nothing to commit."
            exit 0
          fi

          git config user.name "rgpt-bot"
          git config user.email "rgpt-bot@users.noreply.github.com"

          # Create a unique branch off the checked-out target_branch
          ts="$(date -u +%Y%m%d-%H%M%SZ)"
          base="${{ inputs.target_branch }}"
          pr_branch="rgpt/auto-update/${base}/${ts}"

          echo "[AUTO-UPDATE] Creating PR branch: ${pr_branch} (base=${base})"
          git checkout -b "${pr_branch}"

          git add -A
          git commit -m "ops(auto-update): record controlled auto-update evidence"

          # Push branch using PAT (triggers workflows on the PR)
          git push -u origin "${pr_branch}"

          # Create (or re-use) PR back to base
          title="ops(auto-update): controlled update (${base})"
          body="$(cat <<'EOF'
### Controlled Auto-Update Evidence
- mode: ${{ inputs.mode }}
- base: ${base}
- actor: ${{ github.actor }}
- reason: ${{ inputs.reason }}
- sha: ${{ github.sha }}

This PR is created by Auto Update Policy (Controlled) to satisfy repo rules:
- No direct pushes to protected branches
- Changes must go through PR + required checks
EOF
)"

          # If PR already exists for this head branch, just print it
          if gh pr view "${pr_branch}" --repo "${GITHUB_REPOSITORY}" >/dev/null 2>&1; then
            echo "[AUTO-UPDATE] PR already exists for ${pr_branch}:"
            gh pr view "${pr_branch}" --repo "${GITHUB_REPOSITORY}" --json url -q .url
          else
            echo "[AUTO-UPDATE] Creating PR -> ${base}"
            gh pr create \
              --repo "${GITHUB_REPOSITORY}" \
              --base "${base}" \
              --head "${pr_branch}" \
              --title "${title}" \
              --body "${body}"
          fi
