name: Auto Update Policy (Controlled)

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Update mode (allowlist_patch|evidence_only)"
        required: false
        default: "evidence_only"
        type: string
      reason:
        description: "Why is this update needed?"
        required: true
        type: string
      target_branch:
        description: "Branch to operate on"
        required: false
        default: "main"
        type: string

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: auto-update-policy
  cancel-in-progress: false

jobs:
  auto_update:
    name: Controlled Auto-Update
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.target_branch }}

      - name: Preflight â€” clean repo
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "$(git status --porcelain)" ]; then
            echo "::error::Working tree not clean before auto-update"
            git status --porcelain || true
            exit 1
          fi
          echo "[AUTO-UPDATE] Clean working tree confirmed."

      - name: Apply update (L1-only)
        shell: bash
        run: |
          set -euo pipefail

          MODE="${{ inputs.mode }}"
          if [ -z "${MODE}" ]; then MODE="evidence_only"; fi
          echo "[AUTO-UPDATE] mode=${MODE}"

          # Allowed L1 targets (explicit)
          ALLOW_1=".github/auto-ops.yml"

          if [ "${MODE}" = "evidence_only" ]; then
            echo "[AUTO-UPDATE] evidence_only: no repo mutation."
            echo "reason=${{ inputs.reason }}" > auto_update_reason.txt
            exit 0
          fi

          if [ "${MODE}" != "allowlist_patch" ]; then
            echo "::error::Invalid mode: ${MODE}. Allowed: allowlist_patch|evidence_only"
            exit 1
          fi

          if [ ! -f "${ALLOW_1}" ]; then
            echo "::error::Missing allowlist file: ${ALLOW_1}"
            exit 1
          fi

          # Safe patch: append an audit comment
          printf "\n# auto-update: %s by %s\n" "$(date -u +%Y-%m-%dT%H:%M:%SZ)" "${GITHUB_ACTOR}" >> "${ALLOW_1}"
          echo "[AUTO-UPDATE] Patched allowlist: ${ALLOW_1}"

          # Hard stop: ensure ONLY allowed file changed (plus local temp file)
          CHANGED="$(git diff --name-only | sed '/^\s*$/d' || true)"
          echo "[AUTO-UPDATE] Changed files after patch:"
          echo "${CHANGED}" || true

          bad=0
          while IFS= read -r f; do
            [ -z "$f" ] && continue
            case "$f" in
              .github/auto-ops.yml|auto_update_reason.txt)
                ;;
              *)
                echo "::error::Blocked change outside L1 allowlist: $f"
                bad=1 ;;
            esac
          done <<< "${CHANGED}"

          if [ "$bad" -ne 0 ]; then
            exit 1
          fi

      - name: Enforce L0 immutability
        shell: bash
        run: |
          set -euo pipefail
          blocked=0

          git diff --name-only | sed '/^\s*$/d' > changed_files.txt || true

          while IFS= read -r f; do
            case "$f" in
              .github/workflows/policy_gate.yml|\
              docs/ops/policy/POLICY_OWNERSHIP_MATRIX.md|\
              docs/ops/ledger/*)
                echo "::error::Blocked L0 change: $f"
                blocked=1 ;;
              *)
                ;;
            esac
          done < changed_files.txt

          if [ "$blocked" -ne 0 ]; then
            exit 1
          fi

          echo "[AUTO-UPDATE] L0 integrity OK."

      - name: Create execution evidence
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          ts="$(date -u +%Y%m%d-%H%M%SZ)"
          dir="docs/ops/executions/RGPT-S2-C-13"
          mkdir -p "$dir"
          cat > "$dir/AUTO_UPDATE_RUN_$ts.md" <<EOF
          # Auto-Update Policy Run
          - UTC: $ts
          - Branch: ${{ inputs.target_branch }}
          - Actor: ${{ github.actor }}
          - Reason: ${{ inputs.reason }}
          - SHA: ${{ github.sha }}
          EOF

      - name: Commit evidence
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          set -euo pipefail

          # Hard fail if PAT missing (this is the S20C dispatch auth fix)
          if [ -z "${GH_TOKEN:-}" ]; then
            echo "::error::GH_TOKEN / secrets.GH_PAT is not set"
            exit 1
          fi

          if [ -z "$(git status --porcelain)" ]; then
            echo "[AUTO-UPDATE] Nothing to commit."
            exit 0
          fi

          git config user.name "rgpt-bot"
          git config user.email "rgpt-bot@users.noreply.github.com"

          git add -A
          git commit -m "ops(auto-update): record controlled auto-update evidence"

          # Push with PAT-backed GH_TOKEN (prevents auth failure when workflows/dispatch involved)
          git push
