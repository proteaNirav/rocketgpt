name: Self Improve (v4 Core AI)

# RocketGPT v4 Core AI – Self-Improvement Loop
# Foundation docs:
# - docs/self-improvement-charter.md
# - docs/real-self-improving-rocketgpt.md
# - docs/roadmap/v4-core-ai.md
#
# Philosophy (Nirav’s Definition):
# 1) There must be a clear goal. The system takes actions, checks results vs that goal,
#    keeps what helps and corrects what does not. This is an ongoing loop.
# 2) When behavior is wrong, misaligned, or causes problems for others, the system must
#    self-correct so that the same harm/friction does not repeat.
#
# This workflow is a LOW-RISK self-improvement driver:
# - Goal: avoid “stalled” AI codegen issues that never move forward.
# - Actions: periodically scan for open issues with label `codegen:ready` and no open PR.
# - Result check: if such issues exist, nudge `codegen.yml` to act on them.
# - No direct code changes; only triggers other guarded workflows.

on:
  workflow_dispatch:
    inputs:
      reason:
        description: Why this run (manual self-improvement session)
        required: false
  schedule:
    # v4 note: still frequent, but logic is minimal and safe. Can be tuned later.
    - cron: "*/15 * * * *"

jobs:
  plan-and-nudge:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select next improvement
        id: select_next
        run: |
          node scripts/self-improve/select_next.js > selected.json

      - name: Parse selected improvement
        id: parse_selected
        run: |
          node scripts/self-improve/parse_selected.js > parsed_env.txt

          # Append KEY=VALUE lines to GITHUB_ENV
          while IFS= read -r line; do
            echo "$line" >> "$GITHUB_ENV"
          done < parsed_env.txt
    
      - name: Log selected improvement
        run: |
          echo "Selected Improvement:"
          echo "ID:      ${{ env.improvement_id }}"
          echo "Title:   ${{ env.improvement_title }}"
          echo "Status:  ${{ env.improvement_status }}"
          echo "Desc:    ${{ env.improvement_description }}"

      - name: Execute improvement (simulation mode)
        id: execute
        run: |
          node scripts/self-improve/execute.js

      - name: Generate patch for improvement (placeholder)
        id: generate_patch
        run: |
          node scripts/self-improve/patcher.js
          echo "Generated patches directory content:"
          ls -R patches || echo "No patches directory created"

      - name: Apply generated patch (3-way merge)
        if: success()
        env:
          improvement_id: ${{ env.improvement_id }}
          improvement_title: ${{ env.improvement_title }}
          improvement_description: ${{ env.improvement_description }}
          improvement_status: ${{ env.improvement_status }}
        run: |
          echo "Applying patch for ${improvement_id}"

          if [ ! -d patches ]; then
            echo "No patches directory found. Skipping (simulation mode)."
            exit 0
          fi

          PATCH_FILE="patches/${improvement_id}.patch"

          if [ ! -f "$PATCH_FILE" ]; then
            echo "No patch file found for this improvement. Skipping (simulation mode)."
            exit 0
          fi

          echo "Found patch: $PATCH_FILE"
          echo "Attempting 3-way merge (simulation)..."

          if git apply --3way --whitespace=fix "$PATCH_FILE"; then
            echo "Patch applied successfully (simulation)."
          else
            echo "Patch failed to apply (simulation mode) – no changes applied."
            # IMPORTANT: Do NOT fail the job while we are in simulation mode.
            exit 0
          fi


      - name: Find stalled issues (label=codegen:ready, no open PR)
        id: stalled
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const resIssues = await github.rest.search.issuesAndPullRequests({
              q: `repo:${owner}/${repo} is:issue is:open label:codegen:ready`,
              per_page: 10
            });

            const candidates = [];
            for (const it of resIssues.data.items) {
              // Check if there is any open PR referencing this issue number
              const q = `repo:${owner}/${repo} is:pr is:open ${it.number}`;
              const resPr = await github.rest.search.issuesAndPullRequests({ q, per_page: 5 });
              const hasOpenPr = resPr.data.items?.some(x => x.state === "open");
              if (!hasOpenPr) candidates.push(it.number);
            }

            core.info(`Stalled issues (no open PR): ${JSON.stringify(candidates)}`);
            core.setOutput("issue_list", JSON.stringify(candidates));

      - name: Nudge AI Codegen for stalled issues
        if: ${{ steps.stalled.outputs.issue_list != '' && steps.stalled.outputs.issue_list != '[]' }}
        uses: actions/github-script@v7
        with:
          script: |
            // v4 alignment:
            // - Goal: Unblock stalled, ready-for-codegen issues.
            // - No direct merge or workflow edits; only safe workflow dispatches and labels.
            const issues = JSON.parse(`${{ steps.stalled.outputs.issue_list }}`);
            for (const iss of issues) {
              core.info(`Dispatching AI Codegen for #${iss}`);
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: "codegen.yml",
                ref: "main",
                inputs: { issue_number: String(iss) }
              }).catch(e => core.warning(e.message));

              // Nudge label to re-trigger label-based automations, if any.
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: Number(iss),
                labels: ["codegen:ready"]
              }).catch(e => core.warning(e.message));
            }
