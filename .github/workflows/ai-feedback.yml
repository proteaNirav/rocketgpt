name: AI Feedback Analyzer (post-merge)

on:
  pull_request:
    types: [closed]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: ai-feedback-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

jobs:
  analyze:
    # Run when a PR is merged (or manual dispatch)
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event.pull_request.merged == true) }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Ensure feedback folder
        run: mkdir -p rocketgpt-agents/feedback

      - name: Add analyzer script (if missing)
        run: |
          if [ ! -f rocketgpt-agents/feedback/analyzer.js ]; then
            cat > rocketgpt-agents/feedback/analyzer.js <<'JS'
/**
 * analyzer.js
 * Reads score.json from the MERGE commit (generated/<provider>/score.json),
 * updates generated/metrics/engine_metrics.json aggregate, and prints a summary.
 *
 * Usage (env):
 *   MERGE_SHA: merge commit SHA (required on pull_request closed)
 *   PR_NUMBER: PR number
 *   PROVIDERS: csv list to check: "openai,anthropic,google,groq"
 *   REPO:      "owner/repo"
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

function sh(cmd, opts={}) {
  return execSync(cmd, { encoding: 'utf8', stdio: ['pipe','pipe','pipe'], ...opts }).trim();
}

function tryReadFromMerge(mergeSha, provider, filePath) {
  try {
    const showPath = `git show ${mergeSha}:${filePath}`;
    return sh(showPath);
  } catch {
    return null;
  }
}

function loadJSONSafe(fp, fallback=null) {
  try {
    const raw = fs.readFileSync(fp, 'utf8');
    return JSON.parse(raw);
  } catch {
    return fallback;
  }
}

function writeJSONPretty(fp, obj) {
  fs.mkdirSync(path.dirname(fp), { recursive: true });
  fs.writeFileSync(fp, JSON.stringify(obj, null, 2) + '\n', 'utf8');
}

(function main(){
  const MERGE_SHA = process.env.MERGE_SHA || '';
  const PR_NUMBER = process.env.PR_NUMBER || '';
  const PROVIDERS = (process.env.PROVIDERS || 'openai,anthropic,google,groq')
    .split(',').map(s => s.trim()).filter(Boolean);
  const REPO = process.env.REPO || '';

  if (!MERGE_SHA) {
    console.error('MERGE_SHA missing. Exiting.');
    process.exit(1);
  }

  // Locate score.json from this merge (provider paths)
  let found = null;
  for (const p of PROVIDERS) {
    const raw = tryReadFromMerge(MERGE_SHA, p, `generated/${p}/score.json`);
    if (raw) {
      try {
        const obj = JSON.parse(raw);
        const score = Number(obj.overall ?? NaN);
        if (Number.isFinite(score)) {
          found = { provider: p, score, payload: obj };
          break;
        }
      } catch { /* continue */ }
    }
  }

  // If not found in provider-folders, try legacy single-path
  if (!found) {
    const raw = tryReadFromMerge(MERGE_SHA, 'unknown', `generated/score.json`);
    if (raw) {
      try {
        const obj = JSON.parse(raw);
        const score = Number(obj.overall ?? NaN);
        if (Number.isFinite(score)) {
          found = { provider: obj.provider || 'unknown', score, payload: obj };
        }
      } catch { /* ignore */ }
    }
  }

  // Prepare metrics file
  const metricsPath = path.join('generated', 'metrics', 'engine_metrics.json');
  const metrics = loadJSONSafe(metricsPath, {
    updatedAt: null,
    totalMerges: 0,
    engines: {
      openai:     { merges: 0, avgScore: 0, lastScore: null, lastPR: null, lastSeenAt: null },
      anthropic:  { merges: 0, avgScore: 0, lastScore: null, lastPR: null, lastSeenAt: null },
      google:     { merges: 0, avgScore: 0, lastScore: null, lastPR: null, lastSeenAt: null },
      groq:       { merges: 0, avgScore: 0, lastScore: null, lastPR: null, lastSeenAt: null },
      unknown:    { merges: 0, avgScore: 0, lastScore: null, lastPR: null, lastSeenAt: null }
    },
    history: [] // append-only timeline
  });

  const nowIso = new Date().toISOString();
  metrics.updatedAt = nowIso;

  if (found) {
    const p = found.provider;
    const score = found.score;
    metrics.totalMerges += 1;

    if (!metrics.engines[p]) {
      metrics.engines[p] = { merges: 0, avgScore: 0, lastScore: null, lastPR: null, lastSeenAt: null };
    }
    const e = metrics.engines[p];
    // Online average update
    const newMerges = e.merges + 1;
    const newAvg = (e.avgScore * e.merges + score) / newMerges;

    e.merges = newMerges;
    e.avgScore = Number(newAvg.toFixed(2));
    e.lastScore = score;
    e.lastPR = PR_NUMBER || null;
    e.lastSeenAt = nowIso;

    metrics.history.push({
      at: nowIso,
      mergeSha: MERGE_SHA,
      pr: PR_NUMBER || null,
      provider: p,
      score
    });
  } else {
    // No score found; record a hollow event
    metrics.history.push({
      at: nowIso,
      mergeSha: MERGE_SHA,
      pr: PR_NUMBER || null,
      provider: null,
      score: null,
      note: 'No score.json found in merge artifact'
    });
  }

  writeJSONPretty(metricsPath, metrics);

  // Print a concise summary for the workflow log
  const summary = found
    ? `Merged PR #${PR_NUMBER} with provider=${found.provider}, score=${found.score}`
    : `Merged PR #${PR_NUMBER} with NO score.json found`;
  console.log(summary);
})();
JS
          fi

      - name: Resolve merge context
        id: ctx
        uses: actions/github-script@v7
        with:
          script: |
            const isPR = context.eventName === 'pull_request';
            const merged = isPR ? context.payload.pull_request.merged : false;
            const pr = isPR ? context.payload.pull_request.number : null;
            // For merged PRs, use the merge commit SHA; for manual dispatch, use current HEAD
            const mergeSha = isPR ? (context.payload.pull_request.merge_commit_sha || context.payload.pull_request.head.sha) : context.sha;
            core.setOutput('pr', pr);
            core.setOutput('mergeSha', mergeSha);
            core.setOutput('isPR', isPR);
            core.setOutput('merged', merged);

      - name: Run analyzer
        env:
          MERGE_SHA: ${{ steps.ctx.outputs.mergeSha }}
          PR_NUMBER: ${{ steps.ctx.outputs.pr }}
          PROVIDERS: openai,anthropic,google,groq
          REPO: ${{ github.repository }}
        run: node rocketgpt-agents/feedback/analyzer.js

      - name: Commit metrics & open PR
        uses: peter-evans/create-pull-request@v6
        with:
          add-paths: |
            generated/metrics/engine_metrics.json
            rocketgpt-agents/feedback/analyzer.js
          commit-message: "chore(feedback): update engine_metrics from PR #${{ steps.ctx.outputs.pr }}"
          branch: "ops/metrics/update-${{ steps.ctx.outputs.pr || github.run_id }}"
          base: main
          title: "Ops: Update engine metrics (PR #${{ steps.ctx.outputs.pr || 'manual' }})"
          body: |
            This updates `generated/metrics/engine_metrics.json` from the latest merge.

            - PR: #${{ steps.ctx.outputs.pr || 'N/A' }}
            - Merge: `${{ steps.ctx.outputs.mergeSha }}`
            - Source: AI Feedback Analyzer
          labels: ops, ai:metrics

      - name: Drop a short note on merged PR (best effort)
        if: ${{ steps.ctx.outputs.isPR == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const pr = Number(${{
              steps.ctx.outputs.pr
            }});
            const msg = [
              'âœ… **AI Feedback Analyzer** updated repository metrics.',
              '- File: `generated/metrics/engine_metrics.json`',
              '- A PR was opened to record the update.',
            ].join('\n');
            try {
              await github.rest.issues.createComment({ owner, repo, issue_number: pr, body: msg });
            } catch(e) {
              core.warning(`Failed to comment: ${e.message}`);
            }
